rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ==================================================================================
    // GLOBAL FUNCTIONS
    // ==================================================================================

    function isSignedIn() {
      return request.auth != null;
    }

    function getUserId() {
      return request.auth.uid;
    }

    // Fetch the User Profile Document
    function getUserDoc() {
      return get(/databases/$(database)/documents/users/$(getUserId()));
    }

    // Get User Data safely
    function getUserData() {
      let doc = getUserDoc();
      return doc != null ? doc.data : {};
    }

    // GLOBAL ADMIN CHECK
    // Checks if 'role' is 'admin' (case-insensitive-ish)
    function isGlobalAdmin() {
      let data = getUserData();
      let role = data.get('role', '');
      return isSignedIn() && (role == 'admin' || role == 'Admin');
    }

    // COMPANY ACCESS HELPER
    // Returns the role string (e.g. 'financial_manager') or null
    function getCompanyRole(companyId) {
       let data = getUserData();
       let roles = data.get('companyRoles', {});
       return roles.get(companyId, null);
    }

    // CHECK SPECIFIC COMPANY ROLE
    function hasRole(companyId, roleName) {
      // Direct check avoids getting full map if possible? No, we need the map.
      return isSignedIn() && getCompanyRole(companyId) == roleName;
    }

    // RBAC: MANAGER
    // Manager is: Global Admin OR 'admin' of company OR 'financial_manager' of company
    function isManager(companyId) {
      let role = getCompanyRole(companyId);
      return isGlobalAdmin() || role == 'financial_manager' || role == 'admin';
    }

    // GENERIC MEMBER ACCESS (Read Only)
    function isMember(companyId) {
       return isGlobalAdmin() || (isSignedIn() && getCompanyRole(companyId) != null);
    }

    // ==================================================================================
    // COLLECTION RULES
    // ==================================================================================

    // USERS
    match /users/{userId} {
      allow write: if isGlobalAdmin();
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId && 
                    !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'companyRoles', 'status']);
      // Read: 自己 or Admin
      allow read: if isSignedIn() && (request.auth.uid == userId || isGlobalAdmin());
    }

    // COMPANIES
    match /companies/{companyId} {
      // Global Admin Only for mutations
      allow create, update, delete: if isGlobalAdmin();
      // Members can read
      allow read: if isMember(companyId);
    }

    // COST CENTERS
    match /cost_centers/{ccId} {
      allow read, write: if isGlobalAdmin();
      // Read: Member
      allow read: if isMember(resource.data.companyId);
      // Write: Manager (Note: for create, we check request.resource)
      allow create: if isManager(request.resource.data.companyId);
      allow update, delete: if isManager(resource.data.companyId);
    }

    // TRANSACTIONS
    match /transactions/{txId} {
      allow read, write: if isGlobalAdmin();

      // Read: Member
      // Note: Spec implies 'user' only sees OWN transactions.
      // But for simplicity/performance in list queries, we often verify at app level.
      // To strict enforce:
      allow read: if isManager(resource.data.companyId) || 
                     hasRole(resource.data.companyId, 'approver') || 
                     hasRole(resource.data.companyId, 'releaser') || 
                     hasRole(resource.data.companyId, 'auditor') || 
                     (hasRole(resource.data.companyId, 'user') && resource.data.createdBy == request.auth.uid);

      // Create: Manager or User
      allow create: if isManager(request.resource.data.companyId) || hasRole(request.resource.data.companyId, 'user');

      // Update
      allow update: if isManager(resource.data.companyId);
      // User: Own only
      allow update: if hasRole(resource.data.companyId, 'user') && resource.data.createdBy == request.auth.uid;
      // Approver: Status
      allow update: if hasRole(resource.data.companyId, 'approver') && 
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'approvedBy', 'approvedAt', 'updatedAt']);
      // Releaser: Status
      allow update: if hasRole(resource.data.companyId, 'releaser') && 
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'releasedBy', 'releasedAt', 'paymentDate', 'updatedAt']);
                       
      // Delete
      allow delete: if isManager(resource.data.companyId) || 
                       (hasRole(resource.data.companyId, 'user') && resource.data.createdBy == request.auth.uid);
    }

    // RECURRING TEMPLATES
    match /recurring_templates/{id} {
        allow read, write: if isGlobalAdmin();
        allow read: if isMember(resource.data.companyId);
        allow create: if isManager(request.resource.data.companyId);
        allow update, delete: if isManager(resource.data.companyId);
    }

    // PAYMENT BATCHES
    match /payment_batches/{id} {
        allow read, write: if isGlobalAdmin();
        allow read: if isMember(resource.data.companyId);
        allow create: if isManager(request.resource.data.companyId);
        allow delete: if isManager(resource.data.companyId);
        allow update: if isManager(resource.data.companyId);
        // Approver/Releaser Status flows excluded for brevity/safety - Managers can handle batches, or add back if needed.
        allow update: if hasRole(resource.data.companyId, 'approver') && 
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'approvedBy', 'approvedAt', 'updatedAt']);
        allow update: if hasRole(resource.data.companyId, 'releaser') && 
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'releasedBy', 'releasedAt', 'updatedAt']);
    }

    // ENTITIES
    match /entities/{id} {
        allow read, write: if isGlobalAdmin();
        allow read: if isMember(resource.data.companyId);
        allow create: if isManager(request.resource.data.companyId);
        allow update, delete: if isManager(resource.data.companyId);
    }

    // AUDIT LOGS
    match /audit_logs/{id} {
        allow read: if isGlobalAdmin() || 
                       (isSignedIn() && (hasRole(resource.data.companyId, 'auditor') || hasRole(resource.data.companyId, 'approver')));
        allow create: if isSignedIn();
    }

    // BUDGETS
    match /budgets/{id} {
        allow read, write: if isGlobalAdmin();
        allow read: if isMember(resource.data.companyId);
        allow create: if isManager(request.resource.data.companyId);
        allow update, delete: if isManager(resource.data.companyId);
    }
    
    // NOTIFICATIONS
    match /notifications/{id} {
        allow read, write: if isGlobalAdmin();
        allow read, write: if isSignedIn() && resource.data.userId == request.auth.uid;
        allow create: if isSignedIn();
    }
  }
}